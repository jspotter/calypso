var note_offsets = {
	// LEAD
	"lead" : {
		"60": {"left": 159, "top": 317},
		"61": {"left": 54, "top": 15},
		"62": {"left": 303, "top": 216},
		"63": {"left": 10, "top": 162},
		"64": {"left": 285, "top": 45},
		"65": {"left": 71, "top": 300},
		"66": {"left": 136, "top": 4},
		"67": {"left": 251, "top": 291},
		"68": {"left": 16, "top": 78},
		"69": {"left": 325, "top": 133},
		"70": {"left": 23, "top": 245},
		"71": {"left": 228, "top": 8},

		"72": {"left": 183, "top": 251},
		"73": {"left": 129, "top": 104},
		"74": {"left": 248, "top": 209},
		"75": {"left": 86, "top": 185},
		"76": {"left": 243, "top": 128},
		"77": {"left": 139, "top": 251},
		"78": {"left": 175, "top": 84},
		"79": {"left": 230, "top": 248},
		"80": {"left": 93, "top": 142},
		"81": {"left": 261, "top": 169},
		"82": {"left": 105, "top": 230},
		"83": {"left": 220, "top": 95},

		"84": {"left": 158, "top": 206},
		"85": {"left": 193, "top": 152},
		"86": {"left": 203, "top": 213},
		"87": {"left": 155, "top": 172},
		"88": {"left": 220, "top": 179}
	},

	// TENORS
	"tenors": {
		"53": {"left": 0, "top": 70},
		"54": {"left": 510, "top": 207},
		"55": {"left": 333, "top": 74},
		"56": {"left": 242, "top": 70},
		"57": {"left": 36, "top": 9},
		"58": {"left": 578, "top": 95},
		"59": {"left": 363, "top": 6},
	
		"60": {"left": 89, "top": 246},
		"61": {"left": 158, "top": 6},
		"62": {"left": 355, "top": 203},
		"63": {"left": 204, "top": 205},
		"64": {"left": 480, "top": 7},
		"65": {"left": 19, "top": 207},
		"66": {"left": 422, "top": 246},
		"67": {"left": 415, "top": 134},
		"68": {"left": 170, "top": 134},
		"69": {"left": 124, "top": 88},
		"70": {"left": 540, "top": 33},
		"71": {"left": 456, "top": 89},

		"72": {"left": 138, "top": 188},
		"73": {"left": 170, "top": 90},
		"74": {"left": 449, "top": 185},
		"75": {"left": 177, "top": 180},
		"76": {"left": 505, "top": 102},
		"77": {"left": 92, "top": 172},
		"78": {"left": 505, "top": 190},
		"79": {"left": 484, "top": 147},
		"80": {"left": 133, "top": 147},
		"81": {"left": 85, "top": 129},
		"82": {"left": 528, "top": 146}
	},

	// SECONDS
	"seconds": {
		"54": {"left": 40, "top": 213},
		"55": {"left": 380, "top": 8},
		"56": {"left": 62, "top": 6},
		"57": {"left": 364, "top": 205},
		"58": {"left": 206, "top": 192},
		"59": {"left": 540, "top": 192},
	
		"60": {"left": 210, "top": 35},
		"61": {"left": 344, "top": 62},
		"62": {"left": 7, "top": 45},
		"63": {"left": 558, "top": 51},
		"64": {"left": 237, "top": 123},
		"65": {"left": 472, "top": 229},
		"66": {"left": 7, "top": 157},
		"67": {"left": 519, "top": 13},
		"68": {"left": 166, "top": 8},
		"69": {"left": 341, "top": 158},
		"70": {"left": 157, "top": 232},
		"71": {"left": 574, "top": 122},

		"72": {"left": 181, "top": 130},
		"73": {"left": 448, "top": 136},
		"74": {"left": 117, "top": 131},
		"75": {"left": 520, "top": 128},
		"76": {"left": 192, "top": 165},
		"77": {"left": 493, "top": 187},
		"78": {"left": 123, "top": 173},
		"79": {"left": 485, "top": 110},
		"80": {"left": 155, "top": 106},
		"81": {"left": 459, "top": 169},
		"82": {"left": 157, "top": 191},
		"83": {"left": 521, "top": 169},

		"84": {"left": 150, "top": 149},
		"85": {"left": 488, "top": 150}
	},

	// TRIPLES
	"triples": {
		"47": {"left": 125, "top": 228},
	
		"48": {"left": 259, "top": 159},
		"49": {"left": 430, "top": 252},
		"50": {"left": 12, "top": 127},
		"51": {"left": 267, "top": 6},
		"52": {"left": 561, "top": 137},
		"53": {"left": 5, "top": 211},
		"54": {"left": 214, "top": 29},
		"55": {"left": 457, "top": 123},
		"56": {"left": 163, "top": 159},
		"57": {"left": 364, "top": 105},
		"58": {"left": 534, "top": 265},
		"59": {"left": 40, "top": 278},
	
		"60": {"left": 213, "top": 118},
		"61": {"left": 423, "top": 160},
		"62": {"left": 100, "top": 124},
		"63": {"left": 361, "top": 29},
		"64": {"left": 580, "top": 223},
		"65": {"left": 79, "top": 215},
		"66": {"left": 299, "top": 90},
		"67": {"left": 524, "top": 202},
		"68": {"left": 125, "top": 212},
		"69": {"left": 330, "top": 120},
		"70": {"left": 543, "top": 231}
	},

	// NEW TRIPLES
	"new_triples": {
		"46": {"left": 575, "top": 183},
		"47": {"left": 26, "top": 123},
	
		"48": {"left": 259, "top": 159},
		"49": {"left": 425, "top": 267},
		"50": {"left": 81, "top": 263},
		"51": {"left": 214, "top": 21},
		"52": {"left": 426, "top": 136},
		"53": {"left": 138, "top": 132},
		"54": {"left": 354, "top": 19},
		"55": {"left": 528, "top": 135},
		"56": {"left": 9, "top": 245},
		"57": {"left": 279, "top": 7},
		"58": {"left": 539, "top": 280},
		"59": {"left": 5, "top": 174},
	
		"60": {"left": 363, "top": 118},
		"61": {"left": 416, "top": 204},
		"62": {"left": 165, "top": 202},
		"63": {"left": 215, "top": 118},
		"64": {"left": 496, "top": 233},
		"65": {"left": 127, "top": 208},
		"66": {"left": 340, "top": 106},
		"67": {"left": 530, "top": 216},
		"68": {"left": 94, "top": 244},
		"69": {"left": 306, "top": 79},
		"70": {"left": 527, "top": 254},
		"71": {"left": 91, "top": 204},
		
		"72": {"left": 296, "top": 114}
	}
};

var track_nums = {
	"lead": 1,
	"tenors": 2,
	"seconds": 3,
	"triples": 4,
	"new_triples": 4
};

var num_drums = {
	"lead": 1,
	"tenors": 2,
	"seconds": 2,
	"triples": 3,
	"new_triples": 3
};

/*********************************
 * Helper Functions
 */
 
// Plays the appropriate MIDI sound
function play_sound(note) {
	try
	{
		var sound = document.createElement("audio");
		sound.setAttribute("controls", "controls");
		sound.setAttribute("style", "display: none");

		sound.src = "sounds/" + note + ".mp3";
		sound.autoplay = true;
		sound.loop = false;
		sound.volume = 0.05;

		document.body.appendChild(sound);
		setTimeout(function() {
			document.body.removeChild(sound);
		}, 2000);
	}
	catch(err)
	{
		console.log(err);
	}
}

/*********************************
 * Class Drum
 * ----------
 * Represents a single steel drum part.
 * Provides support for setting up notes
 * on screen and handling note on and
 * note off events.
 */
function Drum(type) {
	var this_drum = this;
	this.type = type;
	this.midi_file = {};
	this.my_notes = note_offsets[this.type];
	this.elem = $("#" + this.type);
	this.old_width = this.elem.width();
	this.old_height = this.elem.height();
	this.scale = 1;
	this.click_initialized = false;
	this.hidden = false;

	// Set up this drum
	this.setup = function(top_offset, left_offset, max_width, max_height) {
		var new_width_scale = Math.min(1, max_width / this.old_width);
		var new_height_scale = Math.min(1, max_height / this.old_height);
		var new_scale = Math.min(new_width_scale, new_height_scale);
		var scale_by = new_scale / this.scale;
		this.scale = new_scale;
		this.elem.width(this.elem.width() * scale_by);

		this.elem.offset({
			"top": top_offset,
			"left": left_offset
		});
		offset = this.elem.offset();
		
		// Put notes in place
		for (var key in this.my_notes) {
			var id = this.type + "_" + key;
			var note_elem = $("#" + id);
			old_width = note_elem.width();
			old_height = note_elem.height();
			note_elem
				.attr("name", key)
				.width(old_width * scale_by)
				.height(old_height * scale_by)
				.offset({
					left: offset.left + (note_offsets[this.type][key]["left"] * this.scale),
					top: offset.top + (note_offsets[this.type][key]["top"] * this.scale)
				})

			if (!this.click_initialized) {
				note_elem
					.mousedown(function() {
						this_drum.note_on($(this).attr("name"));
					})
					.mouseup(function() {
						this_drum.note_off($(this).attr("name"));
					})
					.mouseout(function() {
						this_drum.note_off($(this).attr("name"));
					});
			}
		}
		this.click_initialized = true;
	}

	this.hide = function() {
		if (this.hidden)
			return;
			
		this.hidden = true;
		this.elem.hide();
		for (var key in this.my_notes) {
			var id = this.type + "_" + key;
			var note_elem = $("#" + id);
			note_elem.hide();
		}
	}

	this.show = function() {
		if (!this.hidden)
			return;
	
		this.hidden = false;
		this.elem.show();
		for (var key in this.my_notes) {
			var id = this.type + "_" + key;
			var note_elem = $("#" + id);
			note_elem.show();
		}
	}

	this.note_on = function(note) {
		if (this.hidden)
			return;
	
		id = this.type + "_" + note;
		$("#" + id).fadeTo(0, 1);
		
		play_sound(note);
	}

	this.note_off = function(note) {
		id = this.type + "_" + note;
		$("#" + id).fadeTo(0, 0);
	}
}

/****************************
 * Class Manager
 * -------------
 * Class for managing the layout and
 * playback of each drum type. Also handles
 * reading and playing a MIDI file.
 */
function Manager(drums) {
	var this_manager = this;
	this.screen_width = 1000.0;
	this.buffer = 50.0;
	this.midi_step = 10.0;
	this.tempo = 1.5;
	this.next_timeout = undefined;
	this.status_timeout = undefined;
	this.met_timeout = undefined;
	this.ticks_per_beat = undefined;
	this.click_track = true;

	this.drums = {}
	this.drum_statuses = {};
	for (var i = 0; i < drums.length; i++) {
		var drum_type = drums[i];
		this.drums[drum_type] = new Drum(drum_type);
		this.drum_statuses[drum_type] = true;
	}

	this.midi_file = {};
	this.midi_schedule = [];
	this.stopped = true;
	
	// Helper function to compute offsets for a row of drums
	this.compute_offsets = function(drum_plan, cur_row, highest_row) {
		var total_drums = 0;
		var total_types = 0;
		for (var i in cur_row) {
			var drum_type = cur_row[i];
			total_drums += num_drums[drum_type];
			total_types++;
		}
		var max_width = (this.screen_width - this.buffer * (total_types - 1)) /
				total_drums;
		
		var drums_so_far = 0;
		var types_so_far = 0;
		for (var i in cur_row) {
			var drum_type = cur_row[i];
			var my_num_drums = num_drums[drum_type];
			
			drum_plan[drum_type] = 
				[
					highest_row,
					(drums_so_far * max_width) + (types_so_far * this.buffer),
					max_width * my_num_drums
				];
					
			drums_so_far += my_num_drums;
			types_so_far++;
		}
	}

	// Responsible for drawing the drums correctly on screen
	this.setup_drums = function() {
		var drum_plan = {};
		var highest_row = 0;
		var drums_before = 0;
		var cur_row = [];
		
		// Establish width plan first
		for (var drum_type in this.drum_statuses) {
			var status = this.drum_statuses[drum_type];
			var my_num_drums = num_drums[drum_type];
			var my_drum = this.drums[drum_type];
			if (status) {
				if (drums_before + my_num_drums > 6) {
					console.log("new row on " + drum_type);
					console.log("  " + drums_before);
					console.log("  " + my_num_drums);
					this.compute_offsets(drum_plan, cur_row, highest_row);
					highest_row++;
					cur_row = [];
					drums_before = 0;
				}
				
				drums_before += my_num_drums;
				cur_row.push(drum_type);
			}
		}
		this.compute_offsets(drum_plan, cur_row, highest_row);
		
		var max_height = 500 / (highest_row + 1);
		
		// Set up drums
		for (var drum_type in this.drum_statuses) {
			var status = this.drum_statuses[drum_type];
			var my_drum = this.drums[drum_type];
			if (status) {
				my_drum.show();
				my_drum.setup(drum_plan[drum_type][0] * max_height,
						drum_plan[drum_type][1],
						drum_plan[drum_type][2],
						max_height);
			} else {
				my_drum.hide();
			}
		}
	}

	// Hiding and showing drums
	this.show_drum = function(type) {
		if (!this.drum_statuses[type]) {
			this.drum_statuses[type] = true;
			this.setup_drums();
		}
	}

	this.hide_drum = function(type) {
		if (this.drum_statuses[type]) {
			this.drum_statuses[type] = false;
			this.setup_drums();
		}
	}
	
	// Plays a metronome sound
	this.play_metronome = function() {
		this_manager.met_timeout = setTimeout(function() {
			play_sound("0");
			$("#met_vis1").fadeTo(0, 1);
			$("#met_vis2").fadeTo(0, 1);
			$("#met_vis1").fadeTo("fast", 0);
			$("#met_vis2").fadeTo("fast", 0);
		}, 100);
	}

	// Finds the next note on event or note off event,
	// and schedules that event to take place after the
	// appropriate amount of time.
	this.find_next_event = function(index, should_click) {
		if (this_manager.stopped) return;
		if (index >= this_manager.midi_schedule.length) return;
		var pos = parseFloat($("#slider").attr("value"));
		var effective_pos = pos / this_manager.midi_step;
		
		//console.log(new Date().getMilliseconds());
		
		// play notes
		while (true) {
			var delta = this_manager.midi_schedule[index]["delta"];
			if (effective_pos - delta > this_manager.midi_step * this_manager.tempo) {
				index++;
				continue;
			}
			if (delta > effective_pos) break;
			this_manager.handle_event(index);
			index++;
			if (index >= this_manager.midi_schedule.length) break;
		}
		
		//console.log("  " + new Date().getMilliseconds());
		
		// play metronome
		if (should_click) {
			this_manager.play_metronome();
		}
		
		//console.log("  " + new Date().getMilliseconds());
		
		var new_pos = pos + this_manager.midi_step * this_manager.tempo;
		var effective_new_pos = new_pos / this_manager.midi_step;
		var next_click = false;
		
		// determine next click
		if (this_manager.click_track) {
			for (var i = pos + 1; i <= new_pos; i++) {
				if (i % (this_manager.ticks_per_beat * this_manager.midi_step) == 0) {
					next_click = true;
					break;
				}
			}
		}
		
		//console.log("  " + new Date().getMilliseconds());

		$("#slider").val(new_pos);
		
		this_manager.next_timeout = setTimeout(function() {
			this_manager.find_next_event(index, next_click);
		}, 1);
	}

	// Callback for setTimeout
	this.handle_event = function(index) {
		if (this_manager.stopped) return;
		
		var ev = this_manager.midi_schedule[index];
		var drum = this_manager.drums[ev["drum_type"]];
		if (drum === undefined) return;

		var note = ev["note"];
		if (ev["event_type"] == "noteOn")
			drum.note_on(note);
		else if (ev["event_type"] == "noteOff")
			drum.note_off(note);
	}

	// Start playing from MIDI file
	this.play = function() {
		if (!this.stopped) return;
		this.stopped = false;
		this.find_next_event(0, true);
	}

	// Stop playing
	this.stop = function() {
		this.stopped = true;
		
		if (this_manager.next_timeout != undefined) {
			clearTimeout(this_manager.next_timeout);
			this_manager.next_timeout = undefined;
		}
		
		if (this_manager.met_timeout != undefined) {
			clearTimeout(this_manager.met_timeout);
			this_manager.met_timeout = undefined;
		}
		
		for (var type in this.drums) {
			var drum = this.drums[type];
			for (var key in note_offsets[type]) {
				drum.note_off(key);
			}
		}
	}
	
	// Put MIDI note events into a schedule
	this.process_midi = function(file) {
		var tracks = file["tracks"];
		var header = file["header"];
		this_manager.ticks_per_beat = header["ticksPerBeat"];
		
		for (var type in track_nums) {
			var events = tracks[track_nums[type]];
			var total_delta = 0;
			for (var i = 0; i < events.length; i++) {
				var ev = events[i];
				total_delta = total_delta + ev.deltaTime;
				if (ev.subtype == "noteOn" || ev.subtype == "noteOff") {
				
					// make note cut-offs a little early
					var eff_total_delta = total_delta;
					if (ev.subtype == "noteOff")
						eff_total_delta = eff_total_delta - 10;
						
					var to_insert = {
						"delta": eff_total_delta,
						"drum_type": type,
						"event_type": ev.subtype,
						"note": ev.noteNumber
					};
					this_manager.midi_schedule.push(to_insert);
				}
			}
		}
		
		this_manager.midi_schedule.sort(function(a, b) {
			return a["delta"] - b["delta"];
		});
	}
	
	// Constructs MIDI visualization inside controls component
	this.construct_midi_vis = function() {
		var new_thing = $("<div>")
			.css("background-color", "#ffffff")
			.css("position", "absolute")
			.css("bottom", "10px")
			.css("left", "0px")
			.css("width", "100%")
			.css("height", "80px");
		$("body").append(new_thing);
	}
	
	// Constructs a div to flash in time with the metronome
	this.construct_met_vis = function() {
		var met1 = $("<div>",
			{
				id: "met_vis1"
			}
		)
			.css("background-color", "#000000")
			.css("position", "absolute")
			.css("top", "0px")
			.css("left", "0px")
			.css("width", "100%")
			.css("height", "10px")
			.css("display", "none");
		var met2 = $("<div>",
			{
				id: "met_vis2"
			}
		)
			.css("background-color", "#000000")
			.css("position", "absolute")
			.css("bottom", "0px")
			.css("left", "0px")
			.css("width", "100%")
			.css("height", "10px")
			.css("display", "none");
		$("body").append(met1);
		$("body").append(met2);
	}

	// Load MIDI file and set up controls	
	this.load_midi = function(midi_filename) {
		this_manager.set_status_message("Loading " + midi_filename + "...&nbsp;<img src='loading.gif' width='20px' height='20px'></img>", false);
		loadRemote(midi_filename, function(data) {
			this_manager.midi_file = MidiFile(data);
			this_manager.midi_schedule = [];
			this_manager.process_midi(this_manager.midi_file);
			$("#slider").attr("max", this_manager.midi_schedule
					[this_manager.midi_schedule.length - 1].delta
					* this_manager.midi_step);
			this_manager.set_status_message("Successfully loaded "
				+ midi_filename + "!", true);
		});
	}	

	// Add controls at bottom of screen
	this.add_controls = function() {
		// Controller elements
		var play_button = $("<input>", {type: "button", value: "PLAY"})
			.click(function() {
				this_manager.play();
			});
		var stop_button = $("<input>", {type: "button", value: "STOP"})
			.click(function() {
				this_manager.stop();
			});
		var checks = [];
		for (var drum_type in this_manager.drum_statuses) {
			var check = $("<input>", {type: "checkbox", value: drum_type,
					checked: "checked"})
				.click(function() {
					if($(this).attr("checked") == "checked") {
						this_manager.show_drum($(this).attr("value"));
					} else {
						this_manager.hide_drum($(this).attr("value"));
					}
				});
			checks.push(check);
		}
		var click_check = $("<input>", {type: "checkbox", value: "metronome",
				checked: "checked"})
				.click(function() {
					if($(this).attr("checked") == "checked") {
						this_manager.click_track = true;
					} else {
						this_manager.click_track = false;
					}
				});
		checks.push(click_check);
		var slider = $("<input>", 
			{
				type: "range",
				min: "0",
				max: "1",
				value: "0",
				width: "80%",
				id: "slider"
			})
			.change(function() {
				if (!this_manager.stopped) {
					this_manager.stop();
					this_manager.play();
				}
			});
		var tempo = $("<input>",
			{
				type: "range",
				min: "100",
				max: "300",
				value: "150",
				width: "80%",
				id: "tempo"
			})
			.change(function() {
				this_manager.tempo = $(this).val() / 100.0;
			});
		
		// MIDI upload management
		var upload_div = $("<div>",
			{
				id: "upload_div"
			})
			.css("float", "right")
			.css("padding-right", "40px");
		var midis = $("<div>",
			{
				id: "midis"
			})
			.css("float", "right");
		var upload_form = $("<form>",
			{
				id: "upload_form",
				enctype: "multipart/form-data",
				method: "POST",
				action: "upload.php"
			});
		var uploader = $("<input>",
			{
				type: "file",
				name: "midifile",
				id: "midifile"
			});
		var upload_button = $("<input>",
			{
				type: "submit",
				value: "Submit MIDI File"
			});
		upload_form
			.append(uploader)
			.append(upload_button)
			.submit(function() {
				this_manager.set_status_message("Submitting...&nbsp;<img src='loading.gif' width='20px' height='20px'></img>", false);
				$(this).ajaxSubmit(
					{
						success: function(data) {
							this_manager.set_status_message(data, false);
							this_manager.load_midis_control();
						}
					}
				);
				return false;
			});
			
		var status_div = $("<div>",
			{
				id: "status"
			})
			.css("float", "right");
		upload_div
			.append(upload_form)
			.append(midis)
			.append("<br>")
			.append(status_div);
		
		// Add dat shit
		$("#controls")
			.html("")
			.append("Position:&nbsp;")
			.append(slider)
			.append("<br>")
			.append("Tempo:&nbsp;&nbsp;")
			.append(tempo)
			.append(upload_div)
			.append("<br>")
			.append(play_button)
			.append(stop_button)
			.append("<br>");
		for (var i = 0; i < checks.length; i++) {
			$("#controls")
				.append(checks[i].attr("value"))
				.append(checks[i])
				.append("&nbsp;&nbsp;&nbsp;");
		}
		
		//this_manager.construct_midi_vis();
		this_manager.construct_met_vis();
		this_manager.load_midis_control();
	}
	
	this.load_midis_control = function() {
		var select_button = $("<input>",
			{
				type: "button",
				value: "Load MIDI File"
			})
			.click(function() {
				if (!this_manager.stopped) {
					this_manager.stop();
				}
				$("#slider").attr("value", "0");
				this_manager.load_midi("midi/" + $("#midiselect").attr("value"));
			});
		$("#midis").html("Loading file list...&nbsp;<img src='loading.gif' width='20px' height='20px'></img>");
		loadRemote("midis.php", function(data) {
			$("#midis")
				.html(data)
				.append(select_button);
		});
	}
	
	this.set_status_message = function(message, clear) {
		$("#status").html(message);
		if (this_manager.status_timeout != undefined)
			clearTimeout(this_manager.status_timeout);
		if (clear) {
			this_manager.status_timeout = setTimeout(function() {
				$("#status").html("");
			}, 5000);
		}
	}
}

/****************************
 * Taken from:
 * https://github.com/gasman/jasmid/blob/master/index.html
 ***************************/
function loadRemote(path, callback) {
	var fetch = new XMLHttpRequest();
	fetch.open('GET', path);
	fetch.overrideMimeType("text/plain; charset=x-user-defined");
	fetch.onreadystatechange = function() {
		if(this.readyState == 4 && this.status == 200) {
			/* munge response into a binary string */
			var t = this.responseText || "" ;
			var ff = [];
			var mx = t.length;
			var scc= String.fromCharCode;
			for (var z = 0; z < mx; z++) {
				ff[z] = scc(t.charCodeAt(z) & 255);
			}
			callback(ff.join(""));
		}
	}
	fetch.send();
}
/****************************/

